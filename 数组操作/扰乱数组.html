<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script>
			var arr=[1,3,5,4,2,8,6,7];
			

			//splice  O(n^2)
			function shuffle1(arr) {
				var _arr=arr.concat();
				var result = [];
				while (_arr.length) {
				    var index = ~~(Math.random() * _arr.length);
				    result.push(_arr[index]);
				    _arr.splice(index, 1);
				}
				return result;
			}
							
			
			//Math.random() O(nlogn)
			function shuffle2(arr){
				//注意：js搜索引擎默认使用的是插入排序算法
				return arr.concat().sort(function(a,b){
					return Math.random() > .5 ? -1:1;
				});
			}
			//并不能达到非常乱的效果，因为js引擎的Math.random()方法得到的大部分是在0.4到0.5之间
			
			//Fisher–Yates Shuffle O(n)
			//思想：遍历数组元素，将其与之前的任意元素交换
			//从后向前遍历
			function shuffle3(arr) {
			    var _arr = arr.concat();
			    for (var i = _arr.length-1;i>0; i--) {
			    	var j = Math.floor(Math.random() * (i + 1));
			    	var temp = _arr[i];
			    	_arr[i] = _arr[j];
			    	_arr[j] = temp;
			    }
			    return _arr;
			}
			//从前向后遍历
			function shuffle4(arr){
			    var len = arr.length;
			    for(var i = 0; i < len - 1; i++){
			        var idx = Math.floor(Math.random() * (len - i));
			        var temp = arr[idx];
			    	arr[idx] = arr[len - i - 1];
			    	arr[len - i -1] = temp;
			  }
			  return arr;
			}
			/*
			 * ~~
			 * function fn(num) {
    			return isNaN(parseInt(num, 10)) ? -1 : parseInt(num, 10);
    			对于正数和Math.floor结果是一样的，对于负数就不是
			 */
			console.log(shuffle1(arr));
			console.log(shuffle2(arr));
			console.log(shuffle3(arr));
			console.log(shuffle4(arr));
		</script>
	</body>
</html>
